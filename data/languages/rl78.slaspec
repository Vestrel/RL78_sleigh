#########################################################################
# RL78 Core in SLEIGH
#
# Based off of the work from Hedgeberg and aerosoul94
#
# MikeM64, 2020
#########################################################################

#
# Current TODO list:
#   - Register bank selection
#

define endian=little;
define alignment=1;

define space ram        type=ram_space      size=3 default;
define space register   type=register_space size=1;

# Bank 0 - General Purpose
define register offset=0x18 size=1 [X0 A0 C0 B0 E0 D0 L0 H0];  # 8-bit
define register offset=0x18 size=2 [AX0 BC0 DE0 HL0];  #16-bit

# Bank 1 - General Purpose
define register offset=0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1];  # 8-bit
define register offset=0x10 size=2 [AX1 BC1 DE1 HL1];  #16-bit

# Bank 2 - Callee Preserved
define register offset=0x8 size=1 [X2 A2 C2 B2 E2 D2 L2 H2];  # 8-bit
define register offset=0x8 size=2 [AX2 BC2 DE2 HL2];  #16-bit

# Bank 3 - Reserved for Interrupt Handlers
define register offset=0 size=1 [X3 A3 C3 B3 E3 D3 L3 H3];  # 8-bit
define register offset=0 size=2 [AX3 BC3 DE3 HL3];  #16-bit

# Special purpose registers
define register offset=0x40 size=3 [PC];
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x50 size=1 [SPL SPH PSW _ CS ES PMC MEM];

# Per AVR, they put status flags in their own registers for simplicity
define register offset=0x70 size=1 [IE Z PSW_RBS1 AC PSW_RBS0 ISP1 ISP0 CY];

# For storing processor context
define register offset=0x80 size=4 contextreg;

# Fake segment register for the stack
define register offset=0x84 size=1 SS;

define context contextreg
    es_prefix=(0, 0)
    rsb=(1,2)
    skip_mode=(3,5);

BANK0: is rsb=0 {}
BANK1: is rsb=1 {}
BANK2: is rsb=2 {}
BANK3: is rsb=3 {}

X:"X" is BANK0 { export X0; }
X:"X" is BANK1 { export X1; }
X:"X" is BANK2 { export X2; }
X:"X" is BANK3 { export X3; }

A:"A" is BANK0 { export A0; }
A:"A" is BANK1 { export A1; }
A:"A" is BANK2 { export A2; }
A:"A" is BANK3 { export A3; }

C:"C" is BANK0 { export C0; }
C:"C" is BANK1 { export C1; }
C:"C" is BANK2 { export C2; }
C:"C" is BANK3 { export C3; }

B:"B" is BANK0 { export B0; }
B:"B" is BANK1 { export B1; }
B:"B" is BANK2 { export B2; }
B:"B" is BANK3 { export B3; }

E:"E" is BANK0 { export E0; }
E:"E" is BANK1 { export E1; }
E:"E" is BANK2 { export E2; }
E:"E" is BANK3 { export E3; }

D:"D" is BANK0 { export D0; }
D:"D" is BANK1 { export D1; }
D:"D" is BANK2 { export D2; }
D:"D" is BANK3 { export D3; }

L:"L" is BANK0 { export L0; }
L:"L" is BANK1 { export L1; }
L:"L" is BANK2 { export L2; }
L:"L" is BANK3 { export L3; }

H:"H" is BANK0 { export H0; }
H:"H" is BANK1 { export H1; }
H:"H" is BANK2 { export H2; }
H:"H" is BANK3 { export H3; }

AX:"AX" is BANK0 { export AX0; }
AX:"AX" is BANK1 { export AX1; }
AX:"AX" is BANK2 { export AX2; }
AX:"AX" is BANK3 { export AX3; }

BC:"BC" is BANK0 { export BC0; }
BC:"BC" is BANK1 { export BC1; }
BC:"BC" is BANK2 { export BC2; }
BC:"BC" is BANK3 { export BC3; }

DE:"DE" is BANK0 { export DE0; }
DE:"DE" is BANK1 { export DE1; }
DE:"DE" is BANK2 { export DE2; }
DE:"DE" is BANK3 { export DE3; }

HL:"HL" is BANK0 { export HL0; }
HL:"HL" is BANK1 { export HL1; }
HL:"HL" is BANK2 { export HL2; }
HL:"HL" is BANK3 { export HL3; }

# CALL Table entries
define ram offset=0x80 size=2 [
    CALLT80 CALLT82 CALLT84 CALLT86
    CALLT88 CALLT8A CALLT8C CALLT8E

    CALLT90 CALLT92 CALLT94 CALLT96
    CALLT98 CALLT9A CALLT9C CALLT9E

    CALLTA0 CALLTA2 CALLTA4 CALLTA6
    CALLTA8 CALLTAA CALLTAC CALLTAE

    CALLTB0 CALLTB2 CALLTB4 CALLTB6
    CALLTB8 CALLTBA CALLTBC CALLTBE
];

# Implementation-specific special function registers, starting from 0xFFF00
define ram offset=0xFFF00 size=1 [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

define pcodeop divwu;
define pcodeop machu;
define pcodeop mach;

define pcodeop disable_interrupts;
define pcodeop enable_interrupts;

define pcodeop segment; # res:3 = segment(seg:1, addr:2);

#########################################################################
#
# Instruction token and field definitions
#
#########################################################################

define token base (8)
    opcode = (0, 7)
    op_h = (4, 7)
    op_l = (0, 3)
    # Whether an rp (16-bit) register is the data source
    rp_source = (0, 0)
    mov1_sreg   = (7, 7)
    # The n'th bit to use for *1 instructions
    bit_op_n = (4, 6)
    # Register bank selection also uses the same bits
    # as the bitwise operators
    rbs_op_n = (4, 5)
    # Unused instructions
    clrb_unused = (2, 3)
    movw_op = (3, 3)
    call_rp = (4, 6)
    dreg_word = (1, 2)
    dreg_byte = (0, 2)
    dreg_axbc = (0, 1)
    sreg_byte = (0, 2);

DREG_BYTE:^X is X & dreg_byte=0 { export X; }
DREG_BYTE:^A is A & dreg_byte=1 { export A; }
DREG_BYTE:^C is C & dreg_byte=2 { export C; }
DREG_BYTE:^B is B & dreg_byte=3 { export B; }
DREG_BYTE:^E is E & dreg_byte=4 { export E; }
DREG_BYTE:^D is D & dreg_byte=5 { export D; }
DREG_BYTE:^L is L & dreg_byte=6 { export L; }
DREG_BYTE:^H is H & dreg_byte=7 { export H; }

DREG_AXBC:^X is X & dreg_axbc=0 { export X; }
DREG_AXBC:^A is A & dreg_axbc=1 { export A; }
DREG_AXBC:^C is C & dreg_axbc=2 { export C; }
DREG_AXBC:^B is B & dreg_axbc=3 { export B; }

DREG_WORD:^AX is AX & dreg_word=0 { export AX; }
DREG_WORD:^BC is BC & dreg_word=1 { export BC; }
DREG_WORD:^DE is DE & dreg_word=2 { export DE; }
DREG_WORD:^HL is HL & dreg_word=3 { export HL; }

CALL_RP:^AX is AX & call_rp=4 { export AX; }
CALL_RP:^BC is BC & call_rp=5 { export BC; }
CALL_RP:^DE is DE & call_rp=6 { export DE; }
CALL_RP:^HL is HL & call_rp=7 { export HL; }

attach names [ rbs_op_n ] [ RBS0 RBS1 RBS2 RBS3 ];

define token base2 (8)
    # Bits 2, 7 is set and Bit 3 is unset for CALLT instructions
    op2_b7       = (7, 7)
    op2_b23      = (2, 3)
    op2_callt_low = (4, 6)
    op2_callt_hi  = (0, 1)
    # NOTE: Many arithmetic instructions that act upon registers
    # alone are decoded by the upper 5 bits of the second byte
    # of the opcode. Ex. XOR 0x78 >> 3 -> 0xf
    op2_h       = (3, 7)
    # Bit arithmetic uses the nibble of the second byte
    # to determine the operation (See SHR)
    op2_l       = (0, 3)
    shift_n     = (4, 7)
    sreg2_byte  = (0, 2);

SREG2_BYTE:^X is X & sreg2_byte=0 { export X; }
SREG2_BYTE:^A is A & sreg2_byte=1 { export A; }
SREG2_BYTE:^C is C & sreg2_byte=2 { export C; }
SREG2_BYTE:^B is B & sreg2_byte=3 { export B; }
SREG2_BYTE:^E is E & sreg2_byte=4 { export E; }
SREG2_BYTE:^D is D & sreg2_byte=5 { export D; }
SREG2_BYTE:^L is L & sreg2_byte=6 { export L; }
SREG2_BYTE:^H is H & sreg2_byte=7 { export H; }

define token data8 (8)
    data        = (0, 7)
    uaddr8      = (0, 7)
    saddr8      = (0, 7) signed
    sfr_byte    = (0, 7)
    fixed_sfr_offset = (3, 7)
    fixed_sfr   = (0, 2)
    fixed_sfr_w   = (0, 2);

attach variables [ sfr_byte ] [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];
attach variables [ fixed_sfr ] [ SPL SPH PSW _ CS ES PMC MEM ];
attach variables [ fixed_sfr_w ] [ SP _ _ _ _ _ _ _ ];

define token data16 (16)
    dataw = (0, 15)
    uaddr16 = (0, 15)
    saddr16 = (0, 15) signed
    a16_sfr_offset = (3, 15)
    a16_sfr_reg = (0, 2)
    a16w_sfr_reg = (0, 2);
attach variables [ a16_sfr_reg ] [ SPL SPH PSW _ CS ES PMC MEM ];
attach variables [ a16w_sfr_reg ] [ SP _ _ _ _ _ _ _ ];

define token data24 (24)
    uaddr20 = (0, 19);

#########################################################################
#
# Instruction macros
#
#########################################################################

# Section # Page # of RL78/G13 User Manual

# Section 3.4.3 Page 157
macro direct_addr(addr, res) {
    res = segment(0xF:1, addr);
}

macro direct_addr_es(addr, res) {
    res = segment(ES, addr);
}

macro direct_addrb(addr, res) {
    direct_addr(addr, res);
}

macro direct_addrb_es(addr, res) {
    direct_addr_es(addr, res);
}

# Section 3.4.4 Page 158
macro short_direct_addr(addr, res) {
    res = segment(0xF:1, zext(addr) + 0xFE00:2);
}

# Section 3.4.6 Page 160
macro reg_ind(reg1, reg2, res) {
    res = segment(0xF:1, (zext(reg1) << 8) | zext(reg2));
}

# Section 3.4.6 Page 160
macro reg_ind_es(reg1, reg2, res) {
    res = segment(ES, (zext(reg1) << 8) | zext(reg2));
}

macro inst_xch(dst, src) {
    local tmp:1 = dst;
    dst = src;
    src = tmp;
}

macro inst_inc(dst) {
    dst = dst + 1;
    Z = (dst == 0);
    # Generate the carry if the increment generates a carry for bit 4 out of bit 3
    # Clear in all other cases
    AC = (dst == 0x8);
}

macro inst_dec(dst) {
    dst = dst - 1;
    Z = (dst == 0);
    # Generate the carry if the decrement generates a carry for bit 3 out of bit 4
    # Clear in all other cases
    AC = (dst == 0x7);
}

macro inst_add(dst, src) {
    dst = dst + src;
    Z = (dst == 0);
    CY = carry(dst, src);
    AC = (dst & 0x04) < (src & 0x04);
}

macro inst_addc(dst, src) {
    dst = dst + CY;
    inst_add(dst, src);
}

macro inst_sub(dst, src) {
    dst = dst - src;
    Z = (dst == 0);
    CY = src < dst;
    AC = (dst & 0x08) >= (src & 0x08);
}

macro inst_subc(dst, src) {
    dst = dst - CY;
    inst_sub(dst, src);
}

macro inst_and(dst, src) {
    dst = dst & src;
    Z = (dst == 0);
}

macro inst_or(dst, src) {
    dst = dst | src;
    Z = (dst == 0);
}

macro inst_xor(dst, src) {
    dst = dst ^ src;
    Z = (dst == 0);
}

macro inst_incw(dst) {
    dst = dst + 1;
}

macro inst_decw(dst) {
    dst = dst - 1;
}

macro inst_shr(dst, n) {
    CY = (dst:1 & 0x01) != 0;
    dst = dst >> n;
}

macro inst_shl(dst, n) {
    CY = (dst:1 & 0x80) != 0;
    dst = dst << n;
}

macro inst_shlw(dst, n) {
    CY = (dst:2 & 0x8000) != 0;
    dst = dst << n;
}

macro inst_sar(dst, n) {
    local msb:1 = dst & 0x80;
    CY = dst:1 & 0x01;
    dst = dst >> n;
    dst = dst & msb;
}

macro inst_sarw(dst, n) {
    local msb:2 = dst & 0x8000;
    CY = dst:1 & 0x01;
    dst = dst >> n;
    dst = dst & msb;
}

macro inst_cmp(dst, src) {
    Z = dst == src;
    AC = (dst & 0x08) >= (src & 0x08);
    CY = src < dst;
}

macro inst_cmp0(dst) {
    Z = dst == 0;
    AC = 0;
    CY = 0;
}

macro inst_addw(dst, src) {
    CY = carry(dst, src);
    dst = dst + src;
    Z = dst == src;
    AC = 0;
}

macro inst_subw(dst, src) {
    CY = src < dst;
    dst = dst - src;
    Z = dst == src;
    AC = 0;
}

macro inst_cmpw(dst, src) {
    Z = dst == src;
    AC = 0;
    CY = src < dst;
}

macro update_psw(data) {
    # Update PSW as expected
    PSW    = data;
    # Then split it apart into the shadow registers
    # for use during decompilation
    IE     = (data & 0x80) >> 7;
    Z      = (data & 0x40) >> 6;
    PSW_RBS1   = (data & 0x20) >> 5;
    AC     = (data & 0x10) >> 4;
    PSW_RBS0   = (data & 0x08) >> 3;
    ISP1   = (data & 0x04) >> 2;
    ISP0   = (data & 0x02) >> 1;
    CY     = (data & 0x01);
}

macro inst_rolwc(dst) {
    local msb:1 = (dst & 0x8000) != 0;
    dst = dst << 1;
    dst = dst | zext(CY);
    CY = msb;
}

macro mov1_read(dst, src, bit) {
    dst = (src & (1 << bit)) != 0;
}

macro mov1_write(dst, src, bit) {
    dst = dst | (src & (1 << bit));
}

# Destination for AND1 is always CY
macro inst_and1(src, bit) {
    local src_bit:1 = (src & (1 << bit)) >> bit;
    CY = CY & src_bit;
}

# Destination for OR1 is always CY
macro inst_or1(src, bit) {
    local src_bit:1 = (src & (1 << bit) >> bit);
    CY = CY | src_bit;
}

# Destination for XOR1 is always CY
macro inst_xor1(src, bit) {
    local src_bit:1 = (src & (1 << bit) >> bit);
    CY = CY ^ src_bit;
}

macro inst_set1(dst, bit) {
    dst = dst | (1 << bit);
}

macro inst_clr1(dst, bit) {
    dst = dst & (~dst & (0 << bit));
}

macro branch(target) {
    PC = target;
    goto target;
}

macro inst_bt(src, bit, target) {
    if (src & (1 << bit)) goto target;
}

macro inst_bf(src, bit, target) {
    if (!(src & (1 << bit))) goto target;
}

macro inst_btclr(src, bit, target) {
    if (!(src & (1 << bit))) goto target;
    # Clear the bit post-branch, would be a NOP
    # if the bit was not set in the first place
    src = (~src & (0 << bit));
}

#########################################################################
#
# Root table constructors
#
#########################################################################

# Instruction data tokens

u8: "#"data is data {
    local tmp:1 = data;
    export tmp;
}

u16: "#"dataw is dataw {
    local tmp:2 = dataw;
    export tmp;
}

saddr: uaddr8 is uaddr8 {
    local loc:4;
    short_direct_addr(uaddr8:1, loc);
    export *:1 loc;
}

saddrp: uaddr8 is uaddr8 {
    local loc:4;
    short_direct_addr(uaddr8:1, loc);
    export *:2 loc;
}

addr16: "!"uaddr16 is es_prefix=0 & uaddr16 {
    local loc:4;
    direct_addr(uaddr16:2, loc);
    export *:1 loc;
}

addr16: a16_sfr_reg is es_prefix=0 & a16_sfr_reg & a16_sfr_offset=0x1fff {
    export a16_sfr_reg;
}

addr16: ES:"!"uaddr16 is es_prefix=1 & uaddr16 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(uaddr16:2, loc);
    export *:1 loc;
}

addr16w: "!"uaddr16 is es_prefix=0 & uaddr16 {
    local loc:4;
    direct_addr(uaddr16:2, loc);
    export *:2 loc;
}

addr16w: a16w_sfr_reg is es_prefix=0 & a16w_sfr_reg & a16_sfr_offset=0x1fff {
    export a16w_sfr_reg;
}

addr16w: ES:"!"uaddr16 is es_prefix=1 & uaddr16 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(uaddr16:2, loc);
    export *:2 loc;
}

addr20: "!!"uaddr20 is uaddr20 {
    export *:3 uaddr20;
}

sfrp: sfr_byte is sfr_byte {
    export *:1 sfr_byte;
}

sfrp: fixed_sfr is fixed_sfr & fixed_sfr_offset=0x1f {
    export fixed_sfr;
}

sfrpw: sfr_byte is sfr_byte {
    export *:2 sfr_byte;
}

sfrpw: fixed_sfr_w is fixed_sfr_w & fixed_sfr_offset=0x1f {
    export fixed_sfr_w;
}

jdisp8: "$"loc is saddr8 [ loc = inst_next + saddr8; ] {
    export *:3 loc;
}

jaddr16: "!"uaddr16 is uaddr16 {
    local loc:3 = segment(0:1, uaddr16:2);
    export *:3 loc;
}

jdisp16: "$!"loc is saddr16 [ loc = inst_next + saddr16; ] {
    export *:3 loc;
}

brk_addr: loc is opcode [ loc = 0x007F7E; ] {
    export *:3 loc;
}

ret_addr: opcode is opcode {
    local loc:3 = segment(SS, SP);
    SP = SP + 4;
    export *:3 loc;
}

# Register Ponter tokens - [r]

AddrDE: [DE] is es_prefix=0 & DE {
    local loc:4;
    direct_addr(DE, loc);
    export *:1 loc;
}

AddrDE: ES:[DE] is es_prefix=1 & DE & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(DE, loc);
    export *:1 loc;
}

AddrDEW: [DE] is es_prefix=0 & DE {
    local loc:4;
    direct_addr(DE, loc);
    export *:2 loc;
}

AddrDEW: ES:[DE] is es_prefix=1 & DE & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(DE, loc);
    export *:2 loc;
}

AddrDEOffset: [DE+uaddr8] is es_prefix=0 & DE & uaddr8 {
    local loc:4;
    direct_addr(DE, loc);
    loc = loc + uaddr8;
    export *:1 loc;
}

AddrDEOffset: ES:[DE+uaddr8] is es_prefix=1 & DE & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(DE, loc);
    loc = loc + uaddr8;
    export *:1 loc;
}

AddrDEOffsetW: [DE+uaddr8] is es_prefix=0 & DE & uaddr8 {
    local loc:4;
    direct_addr(DE, loc);
    loc = loc + uaddr8;
    export *:2 loc;
}

AddrDEOffsetW: ES:[DE+uaddr8] is es_prefix=1 & DE & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ]{
    local loc:4;
    direct_addr_es(DE, loc);
    loc = loc + uaddr8;
    export *:2 loc;
}

AddrHL: [HL] is HL & es_prefix=0 {
    local loc:4;
    direct_addr(HL, loc);
    export *:1 loc;
}

AddrHL: ES:[HL] is HL & es_prefix=1 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(HL, loc);
    export *:1 loc;
}

AddrHLW: [HL] is es_prefix=0 & HL {
    local loc:4;
    direct_addr(HL, loc);
    export *:2 loc;
}

AddrHLW: ES:[HL] is es_prefix=1 & HL & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(HL, loc);
    export *:2 loc;
}

AddrHLOffset: [HL+uaddr8] is es_prefix=0 & HL & uaddr8 {
    local loc:4;
    direct_addr(HL, loc);
    loc = loc + uaddr8;
    export *:1 loc;
}

AddrHLOffset: ES:[HL+uaddr8] is es_prefix=1 & HL & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ]{
    local loc:4;
    direct_addr_es(HL, loc);
    loc = loc + uaddr8;
    export *:1 loc;
}

AddrHLOffsetW: [HL+uaddr8] is es_prefix=0 & HL & uaddr8 {
    local loc:4;
    direct_addr(HL, loc);
    loc = loc + uaddr8;
    export *:2 loc;
}

AddrHLOffsetW: ES:[HL+uaddr8] is es_prefix=1 & HL & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(HL, loc);
    loc = loc + uaddr8;
    export *:2 loc;
}

AddrHLOffsetB: [HL+B] is es_prefix=0 & HL & B {
    local loc:4;
    direct_addr(HL, loc);
    loc = loc + zext(B);
    export *:1 loc;
}

AddrHLOffsetB: ES:[HL+B] is es_prefix=1 & HL & B & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(HL, loc);
    loc = loc + zext(B);
    export *:1 loc;
}

AddrHLOffsetC: [HL+C] is es_prefix=0 & HL & C {
    local loc:4;
    direct_addr(HL, loc);
    loc = loc + zext(C);
    export *:1 loc;
}

AddrHLOffsetC: ES:[HL+C] is es_prefix=1 & HL & C & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(HL, loc);
    loc = loc + zext(C);
    export *:1 loc;
}

AddrWordOffsetB: uaddr16[B] is es_prefix=0 & uaddr16 & B {
    local loc:4;
    direct_addrb(B, loc);
    loc = loc + uaddr16;
    export *:1 loc;
}

AddrWordOffsetB: ES:uaddr16[B] is es_prefix=1 & uaddr16 & B & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addrb_es(B, loc);
    loc = loc + uaddr16;
    export *:1 loc;
}

AddrWordOffsetBW: uaddr16[B] is es_prefix=0 & uaddr16 & B {
    local loc:4;
    direct_addrb(B, loc);
    loc = loc + uaddr16;
    export *:2 loc;
}

AddrWordOffsetBW: ES:uaddr16[B] is es_prefix=1 & uaddr16 & B & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addrb_es(B, loc);
    loc = loc + uaddr16;
    export *:2 loc;
}

AddrWordOffsetC: uaddr16[C] is es_prefix=0 & uaddr16 & C {
    local loc:4;
    direct_addrb(C, loc);
    loc = loc + uaddr16;
    export *:1 loc;
}

AddrWordOffsetC: ES:uaddr16[C] is es_prefix=1 & uaddr16 & C & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addrb_es(C, loc);
    loc = loc + uaddr16;
    export *:1 loc;
}

AddrWordOffsetCW: uaddr16[C] is es_prefix=0 & uaddr16 & C {
    local loc:4;
    direct_addrb(C, loc);
    loc = loc + uaddr16;
    export *:2 loc;
}

AddrWordOffsetCW: ES:uaddr16[C] is es_prefix=1 & uaddr16 & C & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addrb_es(C, loc);
    loc = loc + uaddr16;
    export *:2 loc;
}

AddrWordOffsetBC: uaddr16[BC] is es_prefix=0 & uaddr16 & BC {
    local loc:4;
    direct_addr(BC, loc);
    loc = loc + uaddr16;
    export *:1 loc;
}

AddrWordOffsetBC: ES:uaddr16[BC] is es_prefix=1 & uaddr16 & BC & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(BC, loc);
    loc = loc + uaddr16;
    export *:1 loc;
}

AddrWordOffsetBCW: uaddr16[BC] is es_prefix=0 & uaddr16 & BC {
    local loc:4;
    direct_addr(BC, loc);
    loc = loc + uaddr16;
    export *:2 loc;
}

AddrWordOffsetBCW: ES:uaddr16[BC] is es_prefix=1 & uaddr16 & BC & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:4;
    direct_addr_es(BC, loc);
    loc = loc + uaddr16;
    export *:2 loc;
}

AddrSPOffset: [SP+uaddr8] is SP & uaddr8 {
    local loc:3 = zext(SP) + uaddr8;
    export *:1 loc;
}

AddrSPOffsetW: [SP+uaddr8] is SP & uaddr8 {
    local loc:3 = zext(SP) + uaddr8;
    export *:2 loc;
}

CALLT_Entry: [ct_entry] is op2_callt_low & op2_callt_hi
    [ ct_entry = 0x80 | ((op2_callt_hi << 4) | op2_callt_low << 1); ] {
    export *:2 ct_entry;
}

# method derived from ARMinstructions.sinc

skip_cond: is skip_mode=1 [ skip_mode=0; globalset(inst_next, skip_mode); ] { export CY; }
skip_cond: is skip_mode=2 [ skip_mode=0; globalset(inst_next, skip_mode); ] { local tmp:1 = !CY; export tmp; }
skip_cond: is skip_mode=3 [ skip_mode=0; globalset(inst_next, skip_mode); ] { export Z; }
skip_cond: is skip_mode=4 [ skip_mode=0; globalset(inst_next, skip_mode); ] { local tmp:1 = !Z; export tmp; }
skip_cond: is skip_mode=5 [ skip_mode=0; globalset(inst_next, skip_mode); ] { local tmp:1 = Z | CY; export tmp; }
skip_cond: is skip_mode=6 [ skip_mode=0; globalset(inst_next, skip_mode); ] { local tmp:1 = !(Z | CY); export tmp; }

SKIP_CHECK: is skip_mode=0 { } # always execute by default
SKIP_CHECK: is skip_cond { if (skip_cond) goto inst_next; }

#########################################################################
#
# Root table instructions
#
#########################################################################

#
# Table 1/30
#

# MOV r, #byte
:MOV DREG_BYTE, "#"data is SKIP_CHECK & op_h=0x5 & DREG_BYTE; data {
    build SKIP_CHECK;
    DREG_BYTE = data;
}

# MOV r, A
:MOV DREG_BYTE, A is SKIP_CHECK & op_h=0x7 & A & DREG_BYTE & dreg_byte!=1 {
    build SKIP_CHECK;
    DREG_BYTE = A;
}

# MOV A, r
:MOV A, DREG_BYTE is SKIP_CHECK & op_h=0x6 & A & DREG_BYTE & dreg_byte!=1 {
    build SKIP_CHECK;
    A = DREG_BYTE;
}

# MOV saddr, #byte
:MOV saddr, "#"data is SKIP_CHECK & opcode=0xCD; saddr; data {
    build SKIP_CHECK;
    saddr = data;
}

# MOV sfr, #byte
:MOV sfr_byte, "#"data is SKIP_CHECK & opcode=0xCE; sfr_byte; data {
    build SKIP_CHECK;
    sfr_byte = data;
}

# MOV !addr16, #byte
:MOV addr16, "#"data is SKIP_CHECK & opcode=0xCF; addr16; data {
    build SKIP_CHECK;
    addr16 = data;
}

# MOV A, saddr
:MOV A, saddr is SKIP_CHECK & opcode=0x8D & A; saddr {
    build SKIP_CHECK;
    A = saddr;
}

# MOV saddr, A
:MOV saddr, A is SKIP_CHECK & opcode=0x9D & A; saddr {
    build SKIP_CHECK;
    saddr = A;
}

# MOV A, sfr
:MOV A, sfrp is SKIP_CHECK & opcode=0x8E & A; sfrp {
    build SKIP_CHECK;
    A = sfrp;
}

# MOV sfr, A
:MOV sfrp, A is SKIP_CHECK & opcode=0x9E & A; sfrp {
    build SKIP_CHECK;
    sfrp = A;
}

# MOV A, !addr16
:MOV A, addr16 is SKIP_CHECK & opcode=0x8F & A; addr16 {
    build SKIP_CHECK;
    A = addr16;
}

# MOV !addr16, A
:MOV addr16, A is SKIP_CHECK & opcode=0x9F & A; addr16 {
    build SKIP_CHECK;
    addr16 = A;
}

# MOV PSW, #byte
:MOV PSW, "#"data is SKIP_CHECK & opcode=0x9F & PSW; opcode=0xFA; data {
    build SKIP_CHECK;
    update_psw(data);
}

# MOV A, PSW
:MOV A, PSW is SKIP_CHECK & opcode=0x8E & A & PSW; opcode=0xFA {
    build SKIP_CHECK;
    A = PSW;
}

# MOV PSW, A
:MOV PSW, A is SKIP_CHECK & opcode=0x9E & A & PSW; opcode=0xFA {
    build SKIP_CHECK;
    update_psw(A);
}

# MOV ES, #byte
:MOV ES, "#"data is SKIP_CHECK & opcode=0x41 & ES; data {
    build SKIP_CHECK;
    ES = data;
}

# MOV ES, saddr
:MOV ES, saddr is SKIP_CHECK & opcode=0x61 & ES; opcode=0xB8; saddr {
    build SKIP_CHECK;
    ES = saddr;
}

# MOV A, ES
:MOV A, ES is SKIP_CHECK & opcode=0x8E & A & ES; opcode=0xFD {
    build SKIP_CHECK;
    A = ES;
}

# MOV ES = A
:MOV ES, A is SKIP_CHECK & opcode=0x9E & A & ES; opcode=0xFD {
    build SKIP_CHECK;
    ES = A;
}

# MOV CS, #byte
:MOV CS, "#"data is SKIP_CHECK & opcode=0xCE & CS; opcode=0xFC; data {
    build SKIP_CHECK;
    CS = data;
}

#
# Table 2/30
#

# MOV A, CS
:MOV A, CS is SKIP_CHECK & opcode=0x8E & A & CS; opcode=0xFC {
    build SKIP_CHECK;
    A = CS;
}

# MOV CS, A
:MOV CS, A is SKIP_CHECK & opcode=0x9E & A & CS; opcode=0xFC {
    build SKIP_CHECK;
    CS = A;
}

# MOV A, [DE]
:MOV A, AddrDE is SKIP_CHECK & opcode=0x89 & A & AddrDE {
    build SKIP_CHECK;
    A = AddrDE;
}

# MOV [DE], A
:MOV AddrDE, A is SKIP_CHECK & opcode=0x99 & A & AddrDE {
    build SKIP_CHECK;
    AddrDE = A;
}

# MOV [DE+byte], #byte
:MOV AddrDEOffset, "#"data is SKIP_CHECK & opcode=0xCA; AddrDEOffset; data {
    build SKIP_CHECK;
    AddrDEOffset = data;
}

# MOV A, [DE+byte]
:MOV A, AddrDEOffset is SKIP_CHECK & opcode=0x8A & A; AddrDEOffset {
    build SKIP_CHECK;
    A = AddrDEOffset;
}

# MOV [DE+byte], A
:MOV AddrDEOffset, A is SKIP_CHECK & opcode=0x9A & A; AddrDEOffset {
    build SKIP_CHECK;
    AddrDEOffset = A;
}

# MOV A, [HL]
:MOV A, AddrHL is SKIP_CHECK & opcode=0x8B & A & AddrHL {
    build SKIP_CHECK;
    A = AddrHL;
}

# MOV [HL], A
:MOV AddrHL, A is SKIP_CHECK & opcode=0x9B & A & AddrHL {
    build SKIP_CHECK;
    AddrHL = A;
}

# MOV [HL+byte], #byte
:MOV AddrHLOffset, u8 is SKIP_CHECK & opcode=0xCC; AddrHLOffset; u8 {
    build SKIP_CHECK;
    AddrHLOffset = u8;
}

# MOV A, [HL+byte]
:MOV A, AddrHLOffset is SKIP_CHECK & opcode=0x8C & A; AddrHLOffset {
    build SKIP_CHECK;
    A = AddrHLOffset;
}

# MOV [HL+byte], A
:MOV AddrHLOffset, A is SKIP_CHECK & opcode=0x9C & A; AddrHLOffset {
    build SKIP_CHECK;
    AddrHLOffset = A;
}

# MOV A, [HL+B]
:MOV A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xC9 & AddrHLOffsetB {
    build SKIP_CHECK;
    A = AddrHLOffsetB;
}

# MOV [HL+B], A
:MOV AddrHLOffsetB, A is SKIP_CHECK & opcode=0x61 & A; opcode=0xD9 & AddrHLOffsetB {
    build SKIP_CHECK;
    AddrHLOffsetB = A;
}

# MOV A, [HL+C]
:MOV A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xE9 & AddrHLOffsetC {
    build SKIP_CHECK;
    A = AddrHLOffsetC;
}

# MOV [HL+C], A
:MOV AddrHLOffsetC, A is SKIP_CHECK & opcode=0x61 & A; opcode=0xF9 & AddrHLOffsetC {
    build SKIP_CHECK;
    AddrHLOffsetC = A;
}

# MOV word[B], #byte
:MOV AddrWordOffsetB, u8 is SKIP_CHECK & opcode=0x19; AddrWordOffsetB; u8 {
    build SKIP_CHECK;
    AddrWordOffsetB = u8;
}

# MOV A, word[B]
:MOV A, AddrWordOffsetB is SKIP_CHECK & opcode=0x09 & A; AddrWordOffsetB {
    build SKIP_CHECK;
    A = AddrWordOffsetB;
}

# MOV word[B], A
:MOV AddrWordOffsetB, A is SKIP_CHECK & opcode=0x18 & A; AddrWordOffsetB {
    build SKIP_CHECK;
    AddrWordOffsetB = A;
}

# MOV word[C], #byte
:MOV AddrWordOffsetC, u8 is SKIP_CHECK & opcode=0x38; AddrWordOffsetC; u8 {
    build SKIP_CHECK;
    AddrWordOffsetC = u8;
}

# MOV A, word[C]
:MOV A, AddrWordOffsetC is SKIP_CHECK & opcode=0x29 & A; AddrWordOffsetC {
    build SKIP_CHECK;
    A = AddrWordOffsetC;
}

# MOV word[C], A
:MOV AddrWordOffsetC, A is SKIP_CHECK & opcode=0x28 & A; AddrWordOffsetC {
    build SKIP_CHECK;
    AddrWordOffsetC = A;
}

# MOV word[BC], #byte
:MOV AddrWordOffsetBC, u8 is SKIP_CHECK & opcode=0x39; AddrWordOffsetBC; u8 {
    build SKIP_CHECK;
    AddrWordOffsetBC = u8;
}

# MOV A, word[BC]
:MOV A, AddrWordOffsetBC is SKIP_CHECK & opcode=0x49 & A; AddrWordOffsetBC {
    build SKIP_CHECK;
    A = AddrWordOffsetBC;
}

# MOV word[BC], A
:MOV AddrWordOffsetBC, A is SKIP_CHECK & opcode=0x48 & A; AddrWordOffsetBC {
    build SKIP_CHECK;
    AddrWordOffsetBC = A;
}

# MOV [SP+byte], #byte
:MOV AddrSPOffset, u8 is SKIP_CHECK & opcode=0xC8; AddrSPOffset; u8 {
    build SKIP_CHECK;
    AddrSPOffset = u8;
}

# MOV A, [SP+byte]
:MOV A, AddrSPOffset is SKIP_CHECK & opcode=0x88 & A; AddrSPOffset {
    build SKIP_CHECK;
    A = AddrSPOffset;
}

# MOV [SP+byte], A
:MOV AddrSPOffset, A is SKIP_CHECK & opcode=0x98 & A; AddrSPOffset {
    build SKIP_CHECK;
    AddrSPOffset = A;
}

# MOV B, saddr
:MOV B, saddr is SKIP_CHECK & opcode=0xE8 & B; saddr {
    build SKIP_CHECK;
    B = saddr;
}

# MOV B, !addr16
:MOV B, addr16 is SKIP_CHECK & opcode=0xE9 & B; addr16 {
    build SKIP_CHECK;
    B = addr16;
}

# MOV C, saddr
:MOV C, saddr is SKIP_CHECK & opcode=0xF8 & C; saddr {
    build SKIP_CHECK;
    C = saddr;
}

# MOV C, !addr16
:MOV C, addr16 is SKIP_CHECK & opcode=0xF9 & C; addr16 {
    build SKIP_CHECK;
    C = addr16;
}

# MOV X, saddr
:MOV X, saddr is SKIP_CHECK & opcode=0xD8 & X; saddr {
    build SKIP_CHECK;
    X = saddr;
}

# MOV X, !addr16
:MOV X, addr16 is SKIP_CHECK & opcode=0xD9 & X; addr16 {
    build SKIP_CHECK;
    X = addr16;
}

#
# Table 3/30
#

# XCH A, X
:XCH A, X is SKIP_CHECK & opcode=0x08 & A & X {
    build SKIP_CHECK;
    inst_xch(A, X);
}

# XCH A, r
:XCH A, SREG2_BYTE is SKIP_CHECK & opcode=0x61; op2_h=0x11 & SREG2_BYTE & sreg2_byte!=1 & A {
    build SKIP_CHECK;
    inst_xch(A, SREG2_BYTE);
}

# XCH A, saddr
:XCH A, saddr is SKIP_CHECK & opcode=0x61 & A; opcode=0xA8; saddr {
    build SKIP_CHECK;
    inst_xch(A, saddr);
}

# XCH A, sfr
:XCH A, sfr_byte is SKIP_CHECK & opcode=0x61 & A; opcode=0xAB; sfr_byte {
    build SKIP_CHECK;
    inst_xch(A, sfr_byte);
}

# XCH A, !addr16
:XCH A, addr16 is SKIP_CHECK & opcode=0x61 & A; opcode=0xAA; addr16 {
    build SKIP_CHECK;
    inst_xch(A, addr16);
}

# XCH A, [DE]
:XCH A, AddrDE is SKIP_CHECK & opcode=0x61 & A; opcode=0xAE & AddrDE {
    build SKIP_CHECK;
    inst_xch(A, AddrDE);
}

# XCH A, [DE+byte]
:XCH A, AddrDEOffset is SKIP_CHECK & opcode=0x61 & A; opcode=0xAF; AddrDEOffset {
    build SKIP_CHECK;
    inst_xch(A, AddrDEOffset);
}

# XCH A, [HL]
:XCH A, AddrHL is SKIP_CHECK & opcode=0x61 & A; opcode=0xAC & AddrHL {
    build SKIP_CHECK;
    inst_xch(A, AddrHL);
}

# XCH A, [HL+byte]
:XCH A, AddrHLOffset is SKIP_CHECK & opcode=0x61 & A; opcode=0xAD; AddrHLOffset {
    build SKIP_CHECK;
    inst_xch(A, AddrHLOffset);
}

# XCH A, [HL+B]
:XCH A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xB9 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_xch(A, AddrHLOffsetB);
}

# XCH A, [HL+C]
:XCH A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xA9 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_xch(A, AddrHLOffsetC);
}

#
# Table 4/30
#

# ONEB r
:ONEB DREG_AXBC is SKIP_CHECK & op_h=0xE & op_l<4 & DREG_AXBC {
    build SKIP_CHECK;
    DREG_AXBC = 1;
}

# ONEB saddr
:ONEB saddr is SKIP_CHECK & opcode=0xE4; saddr {
    build SKIP_CHECK;
    saddr = 1;
}

# ONEB !addr16
:ONEB addr16 is SKIP_CHECK & opcode=0xE5; addr16 {
    build SKIP_CHECK;
    addr16 = 1;
}

# CLRB r
:CLRB DREG_AXBC is SKIP_CHECK & op_h=0xF & DREG_AXBC & clrb_unused=0  {
    build SKIP_CHECK;
    DREG_AXBC = 0;
}

# CLRB saddr
:CLRB saddr is SKIP_CHECK & opcode=0xF4; saddr {
    build SKIP_CHECK;
    saddr = 0;
}

# CLRB !addr16
:CLRB addr16 is SKIP_CHECK & opcode=0xF5; addr16 {
    build SKIP_CHECK;
    addr16 = 0;
}

# MOVS [HL+byte], X
:MOVS X, AddrHLOffset ("Check "A" if zero")is SKIP_CHECK & opcode=0x61 & X & A; opcode=0xCE; AddrHLOffset {
    build SKIP_CHECK;
    AddrHLOffset = X;
    Z = (X == 0);
    CY = (X == 0) | (A == 0);
}

# MOVW rp, #word
:MOVW DREG_WORD, u16 is SKIP_CHECK & op_h=0x3 & DREG_WORD; u16 {
    build SKIP_CHECK;
    DREG_WORD = u16;
}

# MOVW saddrp, #word
:MOVW saddrp, u16 is SKIP_CHECK & opcode=0xC9; saddrp; u16 {
    build SKIP_CHECK;
    saddrp = u16;
}

# MOVW sfr, #word
:MOVW sfrpw, u16 is SKIP_CHECK & opcode=0xCB; sfrpw; u16 {
    build SKIP_CHECK;
    sfrpw = u16;
}

# MOVW AX, saddrp
:MOVW AX, saddrp is SKIP_CHECK & opcode=0xAD & AX; saddrp {
    build SKIP_CHECK;
    AX = saddrp;
}

# MOVW saddrp, AX
:MOVW saddrp, AX is SKIP_CHECK & opcode=0xBD & AX; saddrp {
    build SKIP_CHECK;
    saddrp = AX;
}

# MOVW AX, sfrp
:MOVW AX, sfrpw is SKIP_CHECK & opcode=0xAE & AX; sfrpw {
    build SKIP_CHECK;
    AX = sfrpw;
}

# MOVW sfrp, AX
:MOVW sfrpw, AX is SKIP_CHECK & opcode=0xBE & AX; sfrpw {
    build SKIP_CHECK;
    sfrpw = AX;
}

# MOVW AX, rp
:MOVW AX, DREG_WORD is SKIP_CHECK & op_h=0x1 & AX & DREG_WORD & dreg_word!=0 & rp_source=1 {
    build SKIP_CHECK;
    AX = DREG_WORD;
}

# MOVW rp, AX
:MOVW DREG_WORD, AX is SKIP_CHECK & op_h=0x1 & AX & DREG_WORD & dreg_word!=0 & rp_source=0 {
    build SKIP_CHECK;
    DREG_WORD = AX;
}

# MOVW AX, !addr16
:MOVW AX, addr16w is SKIP_CHECK & opcode=0xAF & AX; addr16w {
    build SKIP_CHECK;
    AX = addr16w;
}

# MOVW !addr16, AX
:MOVW addr16w, AX is SKIP_CHECK & opcode=0xBF & AX; addr16w {
    build SKIP_CHECK;
    addr16w = AX;
}

# MOVW AX, [DE]
:MOVW AX, AddrDEW is SKIP_CHECK & opcode=0xA9 & AX & AddrDEW {
    build SKIP_CHECK;
    AX = AddrDEW;
}

# MOVW [DE], AX
:MOVW AddrDEW, AX is SKIP_CHECK & opcode=0xB9 & AX & AddrDEW {
    build SKIP_CHECK;
    AddrDEW = AX;
}

# MOVW AX, [DE+byte]
:MOVW AX, AddrDEOffsetW is SKIP_CHECK & opcode=0xAA & AX; AddrDEOffsetW {
    build SKIP_CHECK;
    AX = AddrDEOffsetW;
}

# MOVW [DE+byte], AX
:MOVW AddrDEOffsetW, AX is SKIP_CHECK & opcode=0xBA & AX; AddrDEOffsetW {
    build SKIP_CHECK;
    AddrDEOffsetW = AX;
}

# MOVW AX, [HL]
:MOVW AX, AddrHLW is SKIP_CHECK & opcode=0xAB & AX & AddrHLW {
    build SKIP_CHECK;
    AX = AddrHLW;
}

# MOVW [HL], AX
:MOVW AddrHLW, AX is SKIP_CHECK & opcode=0xBB & AX & AddrHLW {
    build SKIP_CHECK;
    AddrHLW = AX;
}

# MOVW AX, [HL+byte]
:MOVW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0xAC & AX; AddrHLOffsetW {
    build SKIP_CHECK;
    AX = AddrHLOffsetW;
}

# MOVW [HL+byte], AX
:MOVW AddrHLOffsetW, AX is SKIP_CHECK & opcode=0xBC & AX; AddrHLOffsetW {
    build SKIP_CHECK;
    AddrHLOffsetW = AX;
}

# MOVW AX, word[B]
:MOVW AX, AddrWordOffsetBW is SKIP_CHECK & opcode=0x59 & AX; AddrWordOffsetBW {
    build SKIP_CHECK;
    AX = AddrWordOffsetBW;
}

#
# Table 5/30
#

# MOVW word[B], AX
:MOVW AddrWordOffsetBW, AX is SKIP_CHECK & opcode=0x58 & AX; AddrWordOffsetBW {
    build SKIP_CHECK;
    AddrWordOffsetBW = AX;
}

# MOVW AX, word[C]
:MOVW AX, AddrWordOffsetCW is SKIP_CHECK & opcode=0x69 & AX; AddrWordOffsetCW {
    build SKIP_CHECK;
    AX = AddrWordOffsetCW;
}

# MOVW word[C], AX
:MOVW AddrWordOffsetCW, AX is SKIP_CHECK & opcode=0x68 & AX; AddrWordOffsetCW {
    build SKIP_CHECK;
    AddrWordOffsetCW = AX;
}

# MOVW AX, word[BC]
:MOVW AX, AddrWordOffsetBCW is SKIP_CHECK & opcode=0x79 & AX; AddrWordOffsetBCW {
    build SKIP_CHECK;
    AX = AddrWordOffsetBCW;
}

# MOVW AX, [SP+byte]
:MOVW AX, AddrSPOffsetW is SKIP_CHECK & opcode=0xA8 & AX; AddrSPOffsetW {
    build SKIP_CHECK;
    AX = AddrSPOffsetW;
}

# MOVW [SP+byte], AX
:MOVW AddrSPOffsetW, AX is SKIP_CHECK & opcode=0xB8 & AX; AddrSPOffsetW {
    build SKIP_CHECK;
    AddrSPOffsetW = AX;
}

# MOVW BC, saddrp
:MOVW BC, saddrp is SKIP_CHECK & opcode=0xDA & BC; saddrp {
    build SKIP_CHECK;
    BC = saddrp;
}

# MOVW BC, !addr16
:MOVW BC, addr16w is SKIP_CHECK & opcode=0xDB & BC; addr16w {
    build SKIP_CHECK;
    BC = addr16w;
}

# MOVW DE, saddrp
:MOVW DE, saddrp is SKIP_CHECK & opcode=0xEA & DE; saddrp {
    build SKIP_CHECK;
    DE = saddrp;
}

# MOVW DE, !addr16
:MOVW DE, addr16w is SKIP_CHECK & opcode=0xEB & DE; addr16w {
    build SKIP_CHECK;
    DE = addr16w;
}

# MOVW HL, saddrp
:MOVW HL, saddrp is SKIP_CHECK & opcode=0xFA & HL; saddrp {
    build SKIP_CHECK;
    HL = saddrp;
}

# MOVW HL, !addr16
:MOVW HL, addr16w is SKIP_CHECK & opcode=0xFB & HL; addr16w {
    build SKIP_CHECK;
    HL = addr16w;
}

# XCHW AX, rp
:XCHW AX, DREG_WORD is SKIP_CHECK & op_h=0x3 & rp_source=1 & DREG_WORD & dreg_word!=0 & AX {
    build SKIP_CHECK;
    local tmp = AX;
    AX = DREG_WORD;
    DREG_WORD = tmp;
}

# ONEW AX
:ONEW AX is SKIP_CHECK & opcode=0xE6 & AX {
    build SKIP_CHECK;
    AX = 1;
}

# ONEW BC
:ONEW BC is SKIP_CHECK & opcode=0xE7 & BC {
    build SKIP_CHECK;
    BC = 1;
}

# CLRW AX
:CLRW AX is SKIP_CHECK & opcode=0xF6 & AX {
    build SKIP_CHECK;
    AX = 0;
}

# CLRW BC
:CLRW BC is SKIP_CHECK & opcode=0xF7 & BC {
    build SKIP_CHECK;
    BC = 0;
}

#
# Table 6/30
#

# ADD A, #byte
:ADD A, u8 is SKIP_CHECK & opcode=0x0C & A; u8 {
    build SKIP_CHECK;
    inst_add(A, u8);
}

# ADD saddr, #byte
:ADD saddr, u8 is SKIP_CHECK & opcode=0x0A; saddr; u8 {
    build SKIP_CHECK;
    inst_add(saddr, u8);
}

# ADD A, r
:ADD A, "A" is SKIP_CHECK & opcode=0x61 & A; opcode=0x1 {
    build SKIP_CHECK;
    inst_add(A, A);
}

# ADD A, r
:ADD A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x01 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_add(A, SREG2_BYTE);
}

# ADD r, A
:ADD SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x00 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_add(SREG2_BYTE, A);
}

# ADD A, saddr
:ADD A, saddr is SKIP_CHECK & opcode=0x0B & A; saddr {
    build SKIP_CHECK;
    inst_add(A, saddr);
}

# ADD A, !addr16
:ADD A, addr16 is SKIP_CHECK & opcode=0x0F & A; addr16 {
    build SKIP_CHECK;
    inst_add(A, addr16);
}

# ADD A, [HL]
:ADD A, AddrHL is SKIP_CHECK & opcode=0x0D & A & AddrHL {
    build SKIP_CHECK;
    inst_add(A, AddrHL);
}

# ADD A, [HL+byte]
:ADD A, AddrHLOffset is SKIP_CHECK & opcode=0x0E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_add(A, AddrHLOffset);
}

# ADD A, [HL+B]
:ADD A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0x80 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_add(A, AddrHLOffsetB);
}

# ADD A, [HL+C]
:ADD A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0x82 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_add(A, AddrHLOffsetC);
}

# ADDC A, #byte
:ADDC A, u8 is SKIP_CHECK & opcode=0x1C & A; u8 {
    build SKIP_CHECK;
    inst_addc(A, u8);
}

# ADDC saddr, #byte
:ADDC saddr, u8 is SKIP_CHECK & opcode=0x1A; saddr; u8 {
    build SKIP_CHECK;
    inst_addc(saddr, u8);
}

# ADDC A, r
:ADDC A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x3 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_addc(A, SREG2_BYTE);
}

# ADDC r, A
:ADDC SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x2 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_addc(A, SREG2_BYTE);
}

#
# Table 7/30
#

# ADDC A, saddr
:ADDC A, saddr is SKIP_CHECK & opcode=0x1B & A; saddr {
    build SKIP_CHECK;
    inst_addc(A, saddr);
}

# ADDC A, !uint16
:ADDC A, addr16 is SKIP_CHECK & opcode=0x1F & A; addr16 {
    build SKIP_CHECK;
    inst_addc(A, addr16);
}

# ADDC A, [HL]
:ADDC A, AddrHL is SKIP_CHECK & opcode=0x1D & A & AddrHL {
    build SKIP_CHECK;
    inst_addc(A, AddrHL);
}

# ADDC A, [HL+byte]
:ADDC A, AddrHLOffset is SKIP_CHECK & opcode=0x1E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_addc(A, AddrHLOffset);
}

# ADDC A, [HL+B]
:ADDC A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0x90 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_addc(A, AddrHLOffsetB);
}

# ADDC A, [HL+C]
:ADDC A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0x92 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_addc(A, AddrHLOffsetC);
}

# SUB A, #byte
:SUB A, u8 is SKIP_CHECK & opcode=0x2C & A; u8 {
    build SKIP_CHECK;
    inst_sub(A, u8);
}

# SUB saddr, #byte
:SUB saddr, u8 is SKIP_CHECK & opcode=0x2A; saddr; u8 {
    build SKIP_CHECK;
    inst_sub(saddr, u8);
}

# SUB A, r
:SUB A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x5 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_sub(A, SREG2_BYTE);
}

# SUB r, A
:SUB SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x4 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_sub(SREG2_BYTE, A);
}

# SUB A, saddr
:SUB A, saddr is SKIP_CHECK & opcode=0x2B & A; saddr {
    build SKIP_CHECK;
    inst_sub(A, saddr);
}

# SUB A, !addr16
:SUB A, addr16 is SKIP_CHECK & opcode=0x2F & A; addr16 {
    build SKIP_CHECK;
    inst_sub(A, addr16);
}

# SUB A, [HL]
:SUB A, AddrHL is SKIP_CHECK & opcode=0x2D & A & AddrHL {
    build SKIP_CHECK;
    inst_sub(A, AddrHL);
}

# SUB A, [HL+byte]
:SUB A, AddrHLOffset is SKIP_CHECK & opcode=0x2E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_sub(A, AddrHLOffset);
}

# SUB A, [HL+B]
:SUB A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xA0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_sub(A, AddrHLOffsetB);
}

# SUB A, [HL+C]
:SUB A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xA2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_sub(A, AddrHLOffsetC);
}

#
# Table 8/30
#

# SUBC A, #byte
:SUBC A, u8 is SKIP_CHECK & opcode=0x3C & A; u8 {
    build SKIP_CHECK;
    inst_subc(A, u8);
}

# SUBC saddr, #byte
:SUBC saddr, u8 is SKIP_CHECK & opcode=0x3A; saddr; u8 {
    build SKIP_CHECK;
    inst_subc(saddr, u8);
}

# SUBC A, r
:SUBC A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x7 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_subc(A, SREG2_BYTE);
}

# SUBC r, A
:SUBC SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x6 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_subc(SREG2_BYTE, A);
}

# SUBC A, saddr
:SUBC A, saddr is SKIP_CHECK & opcode=0x3B & A; saddr {
    build SKIP_CHECK;
    inst_subc(A, saddr);
}

# SUBC A, !addr16
:SUBC A, addr16 is SKIP_CHECK & opcode=0x3F & A; addr16 {
    build SKIP_CHECK;
    inst_subc(A, addr16);
}

# SUBC A, [HL]
:SUBC A, AddrHL is SKIP_CHECK & opcode=0x3D & A & AddrHL {
    build SKIP_CHECK;
    inst_subc(A, AddrHL);
}

# SUBC A, [HL+byte]
:SUBC A, AddrHLOffset is SKIP_CHECK & opcode=0x3E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_subc(A, AddrHLOffset);
}

# SUBC A, [HL+B]
:SUBC A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xB0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_subc(A, AddrHLOffsetB);
}

# SUBC A, [HL+C]
:SUBC A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xB2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_subc(A, AddrHLOffsetC);
}

# AND A, #byte
:AND A, u8 is SKIP_CHECK & opcode=0x5C & A; u8 {
    build SKIP_CHECK;
    inst_and(A, u8);
}

# AND saddr, #byte
:AND saddr, u8 is SKIP_CHECK & opcode=0x5A; saddr; u8 {
    build SKIP_CHECK;
    inst_and(saddr, u8);
}

# AND A, r
:AND A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0xB & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_and(A, SREG2_BYTE);
}

# AND r, A
:AND SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0xA & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_and(SREG2_BYTE, A);
}

#
# Table 9/30
#

# AND A, saddr
:AND A, saddr is SKIP_CHECK & opcode=0x5B & A; saddr {
    build SKIP_CHECK;
    inst_and(A, saddr);
}

# AND A, !addr16
:AND A, addr16 is SKIP_CHECK & opcode=0x5F & A; addr16 {
    build SKIP_CHECK;
    inst_and(A, addr16);
}

# AND A, [HL]
:AND A, AddrHL is SKIP_CHECK & opcode=0x5D & A & AddrHL {
    build SKIP_CHECK;
    inst_and(A, AddrHL);
}

# AND A, [HL+byte]
:AND A, AddrHLOffset is SKIP_CHECK & opcode=0x5E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_and(A, AddrHLOffset);
}

# AND A, [HL+B]
:AND A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xD0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_and(A, AddrHLOffsetB);
}

# AND A, [HL+C]
:AND A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xD2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_and(A, AddrHLOffsetC);
}

# OR A, #byte
:OR A, u8 is SKIP_CHECK & opcode=0x6C & A; u8 {
    build SKIP_CHECK;
    inst_or(A, u8);
}

# OR saddr, #byte
:OR saddr, u8 is SKIP_CHECK & opcode=0x6A; saddr; u8 {
    build SKIP_CHECK;
    inst_or(saddr, u8);
}

# OR A, r
:OR A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0xD & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_or(A, SREG2_BYTE);
}

# OR r, A
:OR SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0xC & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_or(SREG2_BYTE, A);
}

# OR A, saddr
:OR A, saddr is SKIP_CHECK & opcode=0x6B & A; saddr {
    build SKIP_CHECK;
    inst_or(A, saddr);
}

# OR A, !addr16
:OR A, addr16 is SKIP_CHECK & opcode=0x6F & A; addr16 {
    build SKIP_CHECK;
    inst_or(A, addr16);
}

# OR A, [HL]
:OR A, AddrHL is SKIP_CHECK & opcode=0x6D & A & AddrHL {
    build SKIP_CHECK;
    inst_or(A, AddrHL);
}

# OR A, [HL+byte]
:OR A, AddrHLOffset is SKIP_CHECK & opcode=0x6E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_or(A, AddrHLOffset);
}

# OR A, [HL+B]
:OR A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xE0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_or(A, AddrHLOffsetB);
}

# OR A, [HL+C]
:OR A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xE2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_or(A, AddrHLOffsetC);
}

#
# Table 10/30
#

# XOR A, #byte
:XOR A, u8 is SKIP_CHECK & opcode=0x7C & A; u8 {
    build SKIP_CHECK;
    inst_xor(A, u8);
}

# XOR saddr, #byte
:XOR saddr, u8 is SKIP_CHECK & opcode=0x7A; saddr; u8 {
    build SKIP_CHECK;
    inst_xor(saddr, u8);
}

# XOR A, r
:XOR A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0xf & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_xor(A, SREG2_BYTE);
}

# XOR r, A
:XOR SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0xe & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_xor(SREG2_BYTE, A);
}

# XOR A, saddr
:XOR A, saddr is SKIP_CHECK & opcode=0x7B & A; saddr {
    build SKIP_CHECK;
    inst_xor(A, saddr);
}

# XOR A, !addr16
:XOR A, addr16 is SKIP_CHECK & opcode=0x7f & A; addr16 {
    build SKIP_CHECK;
    inst_xor(A, addr16);
}

# XOR A, [HL]
:XOR A, AddrHL is SKIP_CHECK & opcode=0x7D & A & AddrHL {
    build SKIP_CHECK;
    inst_xor(A, AddrHL);
}

# XOR A, [HL+byte]
:XOR A, AddrHLOffset is SKIP_CHECK & opcode=0x7E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_xor(A, AddrHLOffset);
}

# XOR A, [HL+B]
:XOR A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xF0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_xor(A, AddrHLOffsetB);
}

# XOR A, [HL+C]
:XOR A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xF2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_xor(A, AddrHLOffsetC);
}

# CMP A, #byte
:CMP A, u8 is SKIP_CHECK & opcode=0x4C & A; u8 {
    build SKIP_CHECK;
    inst_cmp(A, u8);
}

# CMP saddr, #byte
:CMP saddr, u8 is SKIP_CHECK & opcode=0x4A; saddr; u8 {
    build SKIP_CHECK;
    inst_cmp(saddr, u8);
}

# NOTE: Similar to XOR above, CMP can be simplified by looking
# at the 5 upper bits of the second byte of the instruction.
# 0x48 -> 0x9

# CMP A, r
:CMP A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x9 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_cmp(A, SREG2_BYTE);
}

# CMP r, A
:CMP SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x8 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_cmp(SREG2_BYTE, A);
}

#
# Table 11/30
#

# CMP A, saddr
:CMP A, saddr is SKIP_CHECK & opcode=0x4B & A; saddr {
    build SKIP_CHECK;
    inst_cmp(A, saddr);
}

# CMP A, !addr16
:CMP A, addr16 is SKIP_CHECK & opcode=0x4F & A; addr16 {
    build SKIP_CHECK;
    inst_cmp(A, addr16);
}

# CMP A, [HL]
:CMP A, AddrHL is SKIP_CHECK & opcode=0x4D & A & AddrHL {
    build SKIP_CHECK;
    inst_cmp(A, AddrHL);
}

# CMP A, [HL+byte]
:CMP A, AddrHLOffset is SKIP_CHECK & opcode=0x4E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_cmp(A, AddrHLOffset);
}

# CMP A, [HL+B]
:CMP A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xC0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_cmp(A, AddrHLOffsetB);
}

# CMP A, [HL+C]
:CMP A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xC2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_cmp(A, AddrHLOffsetC);
}

# CMP !addr16, #byte
:CMP addr16, u8 is SKIP_CHECK & opcode=0x40; addr16; u8 {
    build SKIP_CHECK;
    inst_cmp(addr16, u8);
}

# CMP0, r
:CMP0 DREG_AXBC is SKIP_CHECK & op_h=0xD & op_l<4 & DREG_AXBC {
    build SKIP_CHECK;
    inst_cmp0(DREG_AXBC);
}

# CMP0 saddr
:CMP0 saddr is SKIP_CHECK & opcode=0xD4; saddr {
    build SKIP_CHECK;
    inst_cmp0(saddr);
}

# CMP0 !addr16
:CMP0 addr16 is SKIP_CHECK & opcode=0xD5; addr16 {
    build SKIP_CHECK;
    inst_cmp0(addr16);
}

# CMPS X, [HL+byte]
:CMPS X, AddrHLOffset is SKIP_CHECK & opcode=0x61 & X; opcode=0xDE; AddrHLOffset {
    build SKIP_CHECK;
    Z = X == AddrHLOffset;
    CY = (Z != 0) | (AddrHLOffset == 0) | (X == 0);
    AC = (X & 0x08) >= (AddrHLOffset & 0x08);
}

# ADDW AX, #word
:ADDW AX, u16 is SKIP_CHECK & opcode=0x04 & AX; u16 {
    build SKIP_CHECK;
    inst_addw(AX, u16);
}

# ADDW AX, AX
:ADDW "AX", "AX" is SKIP_CHECK & AX & opcode=0x1 {
    build SKIP_CHECK;
    inst_addw(AX, AX);
}

# ADDW AX, rp
:ADDW AX, DREG_WORD is SKIP_CHECK & op_h=0x0 & AX & rp_source=1 & movw_op=0 & DREG_WORD & dreg_word!=0 {
    build SKIP_CHECK;
    inst_addw(AX, DREG_WORD);
}

# ADDW AX, saddrp
:ADDW AX, saddrp is SKIP_CHECK & opcode=0x06 & AX; saddrp {
    build SKIP_CHECK;
    inst_addw(AX, saddrp);
}

# ADDW AX, !addr16
:ADDW AX, addr16w is SKIP_CHECK & opcode=0x02 & AX; addr16w {
    build SKIP_CHECK;
    inst_addw(AX, addr16w);
}

# ADDW AX, [HL+byte]
:ADDW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0x61 & AX; opcode=0x09; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_addw(AX, AddrHLOffsetW);
}

# SUBW AX, #word
:SUBW AX, u16 is SKIP_CHECK & opcode=0x24 & AX; u16 {
    build SKIP_CHECK;
    inst_subw(AX, u16);
}

# SUBW AX, rp
:SUBW AX, DREG_WORD is SKIP_CHECK & op_h=0x2 & AX & rp_source=1 & movw_op=0 & DREG_WORD & dreg_word!=0 {
    build SKIP_CHECK;
    inst_subw(AX, DREG_WORD);
}

# SUBW AX, saddrp
:SUBW AX, saddrp is SKIP_CHECK & opcode=0x26 & AX; saddrp {
    build SKIP_CHECK;
    inst_subw(AX, saddrp);
}

# SUBW AX, !addr16
:SUBW AX, addr16w is SKIP_CHECK & opcode=0x22 & AX; addr16w {
    build SKIP_CHECK;
    inst_subw(AX, addr16w);
}

# SUBW AX, [HL+byte]
:SUBW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0x61 & AX; opcode=0x29; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_subw(AX, AddrHLOffsetW);
}

#
# Table 12/30
#

# CMPW AX, #word
:CMPW AX, u16 is SKIP_CHECK & opcode=0x44 & AX; u16 {
    build SKIP_CHECK;
    inst_cmpw(AX, u16);
}

# CMPW AX, rp
:CMPW AX, DREG_WORD is SKIP_CHECK & op_h=0x4 & AX & rp_source=1 & movw_op=0 & DREG_WORD & dreg_word!=0 {
    build SKIP_CHECK;
    inst_cmpw(AX, DREG_WORD);
}

# CMPW AX, saddrp
:CMPW AX, saddrp is SKIP_CHECK & opcode=0x46 & AX; saddrp {
    build SKIP_CHECK;
    inst_cmpw(AX, saddrp);
}

# CMPW AX, !addr16
:CMPW AX, addr16w is SKIP_CHECK & opcode=0x42 & AX; addr16w {
    build SKIP_CHECK;
    inst_cmpw(AX, addr16w);
}

# CMPW AX, [HL+byte]
:CMPW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0x61 & AX; opcode=0x49; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_cmpw(AX, AddrHLOffsetW);
}

# MULU X
:MULU X (AX"="A"*X") is SKIP_CHECK & opcode=0xD6 & AX & X & A {
    build SKIP_CHECK;
    local aw:2 = zext(A:1);
    local xw:2 = zext(X:1);
    AX = aw * xw;
}

# MULHU
:MULHU ("AXBC="AX"*"BC) is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x01 & AX & BC {
    build SKIP_CHECK;
    local axdw:4 = zext(AX:2);
    local bcdw:4 = zext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2;
}

# MULH
:MULH ("AXBC="AX"*"BC) is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x02 & AX & BC {
    build SKIP_CHECK;
    local axdw:4 = sext(AX:2);
    local bcdw:4 = sext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2;
}

# DIVHU
:DIVHU ("AXDE="AX"/"DE) is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x03 & AX & DE {
    build SKIP_CHECK;
    local axdw:4 = zext(AX:2);
    local dedw:4 = zext(DE:2);

    # Doesn't handle the case where DE is SKIP_CHECK & 0
    local div:4 = axdw / dedw;
    local rem:4 = axdw % dedw;

    dedw = div & 0xFFFF;
    axdw = rem & 0xFFFF;

    DE = dedw:2;
    AX = axdw:2;
}

# DIVWU
:DIVWU is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x04 { divwu(); }

# MACHU
:MACHU is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x05 { machu(); }

# MACH
:MACH is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x06 { mach(); }

# INC r
:INC DREG_BYTE is SKIP_CHECK & op_h=0x8 & DREG_BYTE {
    build SKIP_CHECK;
    inst_inc(DREG_BYTE);
}

# INC saddr
:INC saddr is SKIP_CHECK & opcode=0xA4; saddr {
    build SKIP_CHECK;
    inst_inc(saddr);
}

# INC !addr16
:INC addr16 is SKIP_CHECK & opcode=0xA0; addr16 {
    build SKIP_CHECK;
    inst_inc(addr16);
}

# INC [HL+byte]
:INC AddrHLOffset is SKIP_CHECK & opcode=0x61; opcode=0x59; AddrHLOffset {
    build SKIP_CHECK;
    inst_inc(AddrHLOffset);
}

# DEC r
:DEC DREG_BYTE is SKIP_CHECK & op_h=0x9 & DREG_BYTE {
    build SKIP_CHECK;
    inst_dec(DREG_BYTE);
}

# DEC saddr
:DEC saddr is SKIP_CHECK & opcode=0xB4; saddr {
    build SKIP_CHECK;
    inst_dec(saddr);
}

# DEC !addr16
:DEC addr16 is SKIP_CHECK & opcode=0xB0; addr16 {
    build SKIP_CHECK;
    inst_dec(addr16);
}

# DEC [HL+byte]
:DEC AddrHLOffset is SKIP_CHECK & opcode=0x61; opcode=0x69; AddrHLOffset {
    build SKIP_CHECK;
    inst_dec(AddrHLOffset);
}

#
# Table 13
#

# INCW rp
:INCW DREG_WORD is SKIP_CHECK & op_h=0xA & DREG_WORD {
    build SKIP_CHECK;
    inst_incw(DREG_WORD);
}

# INCW saddrp
:INCW saddrp is SKIP_CHECK & opcode=0xA6; saddrp {
    build SKIP_CHECK;
    inst_incw(saddrp);
}

# INCW !addr16
:INCW addr16w is SKIP_CHECK & opcode=0xA2; addr16w {
    build SKIP_CHECK;
    inst_incw(addr16w);
}

# INCW [HL+byte]
:INCW AddrHLOffsetW is SKIP_CHECK & opcode=0x61; opcode=0x79; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_incw(AddrHLOffsetW);
}

# DECW rp
:DECW DREG_WORD is SKIP_CHECK & op_h=0xB & DREG_WORD {
    build SKIP_CHECK;
    inst_decw(DREG_WORD);
}

# DECW saddrp
:DECW saddrp is SKIP_CHECK & opcode=0xB6; saddrp {
    build SKIP_CHECK;
    inst_decw(saddrp);
}

# DECW !addr16
:DECW addr16w is SKIP_CHECK & opcode=0xB2; addr16w {
    build SKIP_CHECK;
    inst_decw(addr16w);
}

# DECW [HL+byte]
:DECW AddrHLOffset is SKIP_CHECK & opcode=0x61; opcode=0x89; AddrHLOffset {
    build SKIP_CHECK;
    inst_decw(AddrHLOffset);
}

# SHR A, n
:SHR A, shift_n is SKIP_CHECK & opcode=0x31 & A; op2_l=0xA & shift_n {
    build SKIP_CHECK;
    inst_shr(A, shift_n);
}

# SHRW AX, n
:SHRW AX, shift_n is SKIP_CHECK & opcode=0x31 & AX; op2_l=0xE & shift_n {
    build SKIP_CHECK;
    inst_shr(AX, shift_n);
}

#
# Table 14/30
#

# SHL A, n
:SHL A, shift_n is SKIP_CHECK & opcode=0x31 & A; op2_l=0x9 & shift_n {
    build SKIP_CHECK;
    inst_shl(A, shift_n);
}

# SHL B, n
:SHL B, shift_n is SKIP_CHECK & opcode=0x31 & B; op2_l=0x8 & shift_n {
    build SKIP_CHECK;
    inst_shl(B, shift_n);
}

# SHL C, n
:SHL C, shift_n is SKIP_CHECK & opcode=0x31 & C; op2_l=0x7 & shift_n {
    build SKIP_CHECK;
    inst_shl(C, shift_n);
}

# SHLW AX, n
:SHLW AX, shift_n is SKIP_CHECK & opcode=0x31 & AX; op2_l=0xD & shift_n {
    build SKIP_CHECK;
    inst_shlw(AX, shift_n);
}

# SHLW BC, n
:SHLW BC, shift_n is SKIP_CHECK & opcode=0x31 & BC; op2_l=0xC & shift_n {
    build SKIP_CHECK;
    inst_shlw(BC, shift_n);
}

#
# Table 15/30
#

# SAR A, n
:SAR A, shift_n is SKIP_CHECK & opcode=0x31 & A; op2_l=0xB & shift_n {
    build SKIP_CHECK;
    inst_sar(A, shift_n);
}

# SARW AX, n
:SARW AX, shift_n is SKIP_CHECK & opcode=0x31 & AX; op2_l=0xF & shift_n {
    build SKIP_CHECK;
    inst_sarw(AX, shift_n);
}

# ROR A, 1
:ROR A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xDB {
    build SKIP_CHECK;
    local lsb:1 = A & 0x1;
    CY = (lsb != 0);
    A = A >> 1;
    A = A & (CY << 7);
}

# ROL A, 1
:ROL A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xEB {
    build SKIP_CHECK;
    local msb:1 = A & 0x80;
    CY = (msb != 0);
    A = A << 1;
    A = A | CY;
}

# RORC A, 1
:RORC A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xFB {
    build SKIP_CHECK;
    local lsb:1 = A & 1;
    A = A >> 1;
    A = (CY << 7);
    CY = lsb;
}

# ROLC A, 1
:ROLC A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xDC {
    build SKIP_CHECK;
    local msb:1 = (A & 0x80) != 0;
    A = A << 1;
    A = A | CY;
    CY = msb;
}

# ROLWC AX, 1
:ROLWC AX, 1 is SKIP_CHECK & opcode=0x61 & AX; opcode=0xEE {
    build SKIP_CHECK;
    inst_rolwc(AX);
}

# ROLWC BC, 1
:ROLWC BC, 1 is SKIP_CHECK & opcode=0x61 & BC; opcode=0xBC {
    build SKIP_CHECK;
    inst_rolwc(BC);
}

# MOV1 CY, saddr.n
:MOV1 CY, saddr"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0x4 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    mov1_read(CY, saddr, bit_op_n);
}

#
# Table 16/30
#

# MOV1 CY, sfr.n
:MOV1 CY, sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0xC & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    mov1_read(CY, sfrp, bit_op_n);
}

# MOV1 CY, A.n
:MOV1 CY, A"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & A; op_l=0xC & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    mov1_read(CY, A, bit_op_n);
}

# MOV1 CY, PSW.n
:MOV1 CY, PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & PSW; op_l=0xC & bit_op_n; opcode=0xFA {
    build SKIP_CHECK;
    mov1_read(CY, PSW, bit_op_n);
}

# MOV1 CY, [HL].0
:MOV1 CY, AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & AddrHL; op_l=0x4 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    mov1_read(CY, AddrHL, bit_op_n);
}

# MOV1 saddr.n, CY
:MOV1 saddr"."bit_op_n, CY is SKIP_CHECK & opcode=0x71 & CY; op_l=0x1 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    mov1_write(saddr, CY, bit_op_n);
}

#
# Table 17/30
#

# MOV1 sfr.n, CY
:MOV1 sfrp"."bit_op_n, CY is SKIP_CHECK & opcode=0x71 & CY; op_l=0x9 & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    mov1_write(sfrp, CY, bit_op_n);
}

# MOV1 A.n, CY
:MOV1 A"."bit_op_n & 0x7, CY is SKIP_CHECK & opcode=0x71 & CY & A; op_l=0x9 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    mov1_write(A, CY, bit_op_n);
}

# MOV1 PSW.n, CY
:MOV1 PSW"."bit_op_n, CY is SKIP_CHECK & opcode=0x71 & CY & PSW; op_l=0x9 & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    mov1_write(PSW, CY, bit_op_n);
}

# MOV1 [HL].n, CY
:MOV1 AddrHL"."bit_op_n, CY is SKIP_CHECK & opcode=0x71 & CY & AddrHL; op_l=0x1 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    mov1_write(AddrHL, CY, bit_op_n);
}

#
# Table 18/30
#

# AND1 CY, saddr.n
:AND1 CY, saddr"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0x5 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_and1(saddr, bit_op_n);
}

# AND1 CY, sfr.n
:AND1 CY, sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0xD & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_and1(sfrp, bit_op_n);
}

# AND1 CY, A.n
:AND1 CY, A"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & A; op_l=0xD & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_and1(A, bit_op_n);
}

# AND1 CY, PSW.n
:AND1 CY, PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & PSW; op_l=0xD & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_and1(PSW, bit_op_n);
}

#
# Table 19/30
#

# AND1 CY, [HL].n
:AND1 CY, AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & AddrHL; op_l=0x5 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_and1(AddrHL, bit_op_n);
}

# OR1 CY, saddr.n
:OR1 CY, saddr"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0x6 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_or1(saddr, bit_op_n);
}

# OR1 CY, sfr.n
:OR1 CY, sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0xE & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_or1(sfrp, bit_op_n);
}

# OR1 CY, A.n
:OR1 CY, A"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & A; op_l=0xE & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_or1(A, bit_op_n);
}

#
# Table 20/30
#

# OR1 CY, PSW.n
:OR1 CY, PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & PSW; op_l=0xE & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_or1(PSW, bit_op_n);
}

# OR1 CY, [HL].n
:OR1 CY, AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & AddrHL; op_l=0x6 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_or1(AddrHL, bit_op_n);
}

# XOR1 CY, saddr.n
:XOR1 CY, saddr"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0x7 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_xor1(saddr, bit_op_n);
}

# XOR1 CY, sfr.n
:XOR1 CY, sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY; op_l=0xF & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_xor(sfrp, bit_op_n);
}

#
# Table 21/30
#

# XOR1 CY, A.n
:XOR1 CY, A"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & A; op_l=0xF & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_xor(A, bit_op_n);
}

# XOR1 CY, PSW.n
:XOR1 CY, PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & PSW; op_l=0xF & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_xor(PSW, bit_op_n);
}

# XOR1 CY, [HL].n
:XOR1 CY, AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & CY & AddrHL; op_l=0x7 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_xor(PSW, bit_op_n);
}

# SET1 saddr.n
:SET1 saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x2 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_set1(saddr, bit_op_n);
}

#
# Table 22/30
#

# SET1 sfr.n
:SET1 sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xA & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_set1(sfrp, bit_op_n);
}

# SET1 A.n
:SET1 A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xA & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_set1(A, bit_op_n);
}

# SET1 !addr16.n
:SET1 addr16"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0 & bit_op_n & mov1_sreg=0; addr16 {
    build SKIP_CHECK;
    inst_set1(addr16, bit_op_n);
}

# SET1 PSW.n
:SET1 PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xA & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_set1(PSW, bit_op_n);
    update_psw(PSW);
}

# SET1 [HL].n
:SET1 AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x2 & bit_op_n & mov1_sreg=1 & AddrHL {
    build SKIP_CHECK;
    inst_set1(AddrHL, bit_op_n);
}

#
# Table 23/30
#

# CLR1 saddr.n
:CLR1 saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x3 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_clr1(saddr, bit_op_n);
}

# CLR1 sfr.n
:CLR1 sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xB & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_clr1(sfrp, bit_op_n);
}

# CLR1 A.n
:CLR1 A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xB & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_clr1(A, bit_op_n);
}

#
# Table 24/30
#

# CLR1 !addr16.n
:CLR1 addr16"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x8 & bit_op_n & mov1_sreg=0; addr16 {
    build SKIP_CHECK;
    inst_clr1(addr16, bit_op_n);
}

# CLR1 PSW.n
:CLR1 PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xB & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_clr1(PSW, bit_op_n);
    update_psw(PSW);
}

# CLR1 [HL].n
:CLR1 AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x3 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_clr1(AddrHL, bit_op_n);
}

# SET1 CY
:SET1 CY is SKIP_CHECK & opcode=0x71 & CY; opcode=0x80 {
    build SKIP_CHECK;
    inst_set1(CY, 0);
}

# CLR1 CY
:CLR1 CY is SKIP_CHECK & opcode=0x71 & CY; opcode=0x88 {
    build SKIP_CHECK;
    inst_clr1(CY, 0);
}

# NOT1 CY
:NOT1 CY is SKIP_CHECK & opcode=0x71 & CY; opcode=0xC0 {
    build SKIP_CHECK;
    CY = ~CY & 0x1;
}

#
# Table 25/30
#

# CALL rp
:CALL CALL_RP is SKIP_CHECK & opcode=0x61; CALL_RP & op_l=0xA & mov1_sreg=1 {
    build SKIP_CHECK;
    local ret_pc:4 = inst_next;
    SP = SP - 4;
    local loc:3 = segment(SS, SP);
    *loc = ret_pc;
    loc = segment(CS, CALL_RP);
    PC = loc;
    call [loc];
}

# CALL $!addr20
:CALL jdisp16 is SKIP_CHECK & opcode=0xFE; jdisp16 {
    build SKIP_CHECK;
    local ret_pc:4 = inst_next;
    SP = SP - 4;
    local loc:3 = segment(SS, SP);
    *loc = ret_pc;
    PC = loc;
    call jdisp16;
}

# CALL !addr16
:CALL jaddr16 is SKIP_CHECK & opcode=0xFD; jaddr16 {
    build SKIP_CHECK;
    local ret_pc:4 = inst_next;
    SP = SP - 4;
    local loc:3 = segment(SS, SP);
    *loc = ret_pc;

    call jaddr16;
}

# CALL !!addr20
:CALL addr20 is SKIP_CHECK & opcode=0xFC; addr20 {
    build SKIP_CHECK;
    local ret_pc:4 = inst_next;
    SP = SP - 4;
    local loc:3 = segment(SS, SP);
    *loc = ret_pc;

    call addr20;
}

# CALLT [CALLT]
:CALLT CALLT_Entry is SKIP_CHECK & opcode=0x61; CALLT_Entry & op2_callt_hi & op2_callt_low & op2_b7=1 & op2_b23=0x1 {
    build SKIP_CHECK;
    local ret_pc:4 = inst_next;
    SP = SP - 4;
    local loc:3 = segment(SS, SP);
    *loc = ret_pc;

    call CALLT_Entry;
}

# BRK
:BRK is SKIP_CHECK & opcode=0x61; opcode=0xCC & brk_addr {
    build SKIP_CHECK;
    SP = SP - 1;
    local ret_pc:4 = inst_next;
    local loc:3 = segment(SS, SP);
    *loc = ret_pc;
    SP = SP - 1;
    *:1 loc = PSW;
    SP = SP - 3;
    loc = segment(SS, SP);
    *:3 loc = inst_next;

    IE = 0;
    PSW = PSW & 0x7f;
    update_psw(PSW);

    call brk_addr;
}

# RET
:RET is SKIP_CHECK & opcode=0xD7 & ret_addr {
    build SKIP_CHECK;
    return [ret_addr];
}

# RETI
:RETI (PC) is SKIP_CHECK & opcode=0x61; opcode=0xFC & PC {
    build SKIP_CHECK;
    local loc:3 = segment(SS, SP);
    PC = *:3 loc;
    SP = SP + 3;
    loc = segment(SS, SP);
    update_psw(*:1 loc);
    SP = SP + 1;

    return [PC];
}

# RETB
:RETB (PC) is SKIP_CHECK & opcode=0x61; opcode=0xEC & PC {
    build SKIP_CHECK;
    local loc:3 = segment(SS, SP);
    PC = *:3 loc;
    SP = SP + 3;
    loc = segment(SS, SP);
    update_psw(*:1 loc);
    SP = SP + 1;

    return [PC];
}

#
# Table 26/30
#

# PUSH PSW
:PUSH PSW is SKIP_CHECK & opcode=0x61 & PSW; opcode=0xDD {
    build SKIP_CHECK;
    SP = SP - 2;
    local loc:3 = segment(SS, SP);
    *:2 loc = zext(PSW);
}

# PUSH rp
:PUSH DREG_WORD is SKIP_CHECK & op_h=0xC & DREG_WORD & rp_source=1 {
    build SKIP_CHECK;
    SP = SP - 2;
    local loc:3 = segment(SS, SP);
    *:2 loc = DREG_WORD;
}

# POP PSW
:POP PSW is SKIP_CHECK & opcode=0x61 & PSW; opcode=0xCD {
    build SKIP_CHECK;
    local loc:3 = segment(SS, SP);
    local status:2 = *:2 loc;
    SP = SP + 2;
    update_psw(status:1);
}

# POP rp
:POP DREG_WORD is SKIP_CHECK & op_h=0xC & DREG_WORD & rp_source=0 {
    build SKIP_CHECK;
    local loc:3 = segment(SS, SP);
    SP = SP + 2;
    DREG_WORD = *:2 loc;
}

# MOVW SP, #word
:MOVW SP, u16 is SKIP_CHECK & opcode=0xCB & SP; opcode=0xF8; u16 {
    build SKIP_CHECK;
    SP = u16;
}

# MOVW SP, AX
:MOVW SP, AX is SKIP_CHECK & opcode=0xBE & SP & AX; opcode=0xF8 {
    build SKIP_CHECK;
    SP = AX;
}

# MOVW AX, SP
:MOVW AX, SP is SKIP_CHECK & opcode=0xAE & SP & AX; opcode=0xF8 {
    build SKIP_CHECK;
    AX = SP;
}

# The following show an additional addr16 on the opcode in
# the ISA documentation. This SKIP_CHECK & looks like it may be a documentation
# error as they're all register operands.
# They're also commented out as they conflict with other MOVW instructions... See MOVW BC, !addr16 for example.

# MOVW BC, SP
#:MOVW BC, SP is SKIP_CHECK & opcode=0xDB & BC & SP {
#    BC = SP;
#}

# MOVW DE, SP
#:MOVW DE, SP is SKIP_CHECK & opcode=0xEB & DE & SP {
#    DE = SP;
#}

# MOVW HL, SP
#:MOVW HL, SP is SKIP_CHECK & opcode=0xFB & HL & SP {
#    HL = SP;
#}

# ADDW SP, #byte
:ADDW SP, u8 is SKIP_CHECK & opcode=0x10 & SP; u8 {
    build SKIP_CHECK;
    SP = SP + zext(u8);
}

# SUBW SP, #byte
:SUBW SP, u8 is SKIP_CHECK & opcode=0x20 & SP; u8 {
    build SKIP_CHECK;
    SP = SP - zext(u8);
}

# BR AX
:BR AX is SKIP_CHECK & opcode=0x61 & AX; opcode=0xCB {
    build SKIP_CHECK;
    local addr:4 = segment(CS, AX);
    PC = addr:3;
    goto [PC];
}

# BR $addr20
:BR jdisp8 is SKIP_CHECK & opcode=0xEF; jdisp8 {
    build SKIP_CHECK;
    branch(jdisp8);
}

# BR $!addr20
:BR jdisp16 is SKIP_CHECK & opcode=0xEE; jdisp16 {
    build SKIP_CHECK;
    branch(jdisp16);
}

# BR !addr16
:BR jaddr16 is SKIP_CHECK & opcode=0xED; jaddr16 {
    build SKIP_CHECK;
    branch(jaddr16);
}

# BR !!addr20
:BR addr20 is SKIP_CHECK & opcode=0xEC; addr20 {
    build SKIP_CHECK;
    branch(addr20);
}

# BC $addr20
# P-code doesn't allow for conditional register updates
# Only a conditional goto
:BC jdisp8 is SKIP_CHECK & opcode=0xDC; jdisp8 {
    build SKIP_CHECK;
    if (CY) goto jdisp8;
    goto inst_next;
}

# BNC $addr20
:BNC jdisp8 is SKIP_CHECK & opcode=0xDE; jdisp8 {
    build SKIP_CHECK;
    if (!CY) goto jdisp8;
}

# BZ $addr20
:BZ jdisp8 is SKIP_CHECK & opcode=0xDD; jdisp8 {
    build SKIP_CHECK;
    if (Z) goto jdisp8;
}

# BNZ $addr20
:BNZ jdisp8 is SKIP_CHECK & opcode=0xDF; jdisp8 {
    build SKIP_CHECK;
    if (!Z) goto jdisp8;
}

# BH $addr20
:BH jdisp8 is SKIP_CHECK & opcode=0x61; opcode=0xC3; jdisp8 {
    build SKIP_CHECK;
    if (!(Z | CY)) goto jdisp8;
}

# BNH $addr20
:BNH jdisp8 is SKIP_CHECK & opcode=0x61; opcode=0xD3; jdisp8 {
    build SKIP_CHECK;
    if (Z | CY) goto jdisp8;
}

# BT saddr.n, $addr20
:BT saddr"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x2 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    build SKIP_CHECK;
    inst_bt(saddr, bit_op_n, jdisp8);
}

# BT sfr.n, $addr20
:BT sfrp"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x2 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    build SKIP_CHECK;
    inst_bt(sfrp, bit_op_n, jdisp8);
}

#
# Table 27/30
#

# BT A.n, $addr20
:BT A"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & A; op_l=0x3 & bit_op_n & mov1_sreg=0; jdisp8 {
    build SKIP_CHECK;
    inst_bt(A, bit_op_n, jdisp8);
}

# BT PSW.n, $addr20
:BT PSW"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & PSW; op_l=0x2 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    build SKIP_CHECK;
    inst_bt(PSW, bit_op_n, jdisp8);
}

# BT [HL].n, $addr20
:BT AddrHL"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & AddrHL; op_l=0x3 & bit_op_n & mov1_sreg=1; jdisp8 {
    build SKIP_CHECK;
    inst_bt(AddrHL, bit_op_n, jdisp8);
}

# BF saddr.n, $addr20
:BF saddr"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x4 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    build SKIP_CHECK;
    inst_bf(saddr, bit_op_n, jdisp8);
}

#
# Table 28/30
#

# BF sfr.n, $addr20
:BF sfrp"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x4 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    build SKIP_CHECK;
    inst_bf(sfrp, bit_op_n, jdisp8);
}

# BF A.n, $addr20
:BF A"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & A; op_l=0x5 & bit_op_n & mov1_sreg=0; jdisp8 {
    build SKIP_CHECK;
    inst_bf(A, bit_op_n, jdisp8);
}

# BF PSW.n, $addr20
:BF PSW"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & PSW; op_l=0x4 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    build SKIP_CHECK;
    inst_bf(PSW, bit_op_n, jdisp8);
}

# BF [HL].n, $addr20
:BF AddrHL"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & AddrHL; op_l=0x5 & bit_op_n & mov1_sreg=1; jdisp8 {
    build SKIP_CHECK;
    inst_bf(AddrHL, bit_op_n, jdisp8);
}

#
# Table 29/30
#

# BTCLR saddr.n, $addr20
:BTCLR saddr"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x0 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(saddr, bit_op_n, jdisp8);
}

# BTCLR sfr.n, $addr20
:BTCLR sfrp"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x0 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(sfrp, bit_op_n, jdisp8);
}

# BTCRL A.n, $addr20
:BTCLR A"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & A; op_l=0x1 & bit_op_n & mov1_sreg=0; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(A, bit_op_n, jdisp8);
}

# BTCLR PSW.n, $addr20
:BTCLR PSW"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & PSW; op_l=0x0 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(PSW, bit_op_n, jdisp8);
    update_psw(PSW);
}

# BTCRL [HL].n, $addr20
:BTCLR AddrHL"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & AddrHL; op_l=0x1 & bit_op_n & mov1_sreg=1; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(AddrHL, bit_op_n, jdisp8);
}

#
# Table 30/30
#

# SKC
:SKC is opcode=0x61; opcode=0xC8 [ skip_mode=1; globalset(inst_next, skip_mode); ] { }

# SKNC
:SKNC is opcode=0x61; opcode=0xD8 [ skip_mode=2; globalset(inst_next, skip_mode); ] { }

# SKZ
:SKZ is opcode=0x61; opcode=0xE8 [ skip_mode=3; globalset(inst_next, skip_mode); ] { }

# SKNZ
:SKNZ is opcode=0x61; opcode=0xF8 [ skip_mode=4; globalset(inst_next, skip_mode); ] { }

# SKNH
:SKNH is opcode=0x61; opcode=0xF3 [ skip_mode=5; globalset(inst_next, skip_mode); ] { }

# SKH
:SKH is opcode=0x61; opcode=0xE3 [ skip_mode=6; globalset(inst_next, skip_mode); ] { }

# SEL RBn
:SEL rbs_op_n is opcode=0x61; op_l=0xF & rbs_op_n & mov1_sreg=1 [
    rsb = rbs_op_n;
    globalset(inst_next, rsb);
] {}

# NOP
:NOP is opcode=0x00 {}

# EI
:EI is SKIP_CHECK & opcode=0x71; opcode=0x7A; opcode=0xFA {
    build SKIP_CHECK;
    PSW = PSW | (1 << 7);
    update_psw(PSW);
    enable_interrupts();
}

# DI
:DI is SKIP_CHECK & opcode=0x71; opcode=0x7B; opcode=0xFA {
    build SKIP_CHECK;
    PSW = PSW & (0 << 7);
    update_psw(PSW);
    disable_interrupts();
}

# HALT
:HALT is SKIP_CHECK & opcode=0x61; opcode=0xED { build SKIP_CHECK; halt(); }

# STOP
:STOP is SKIP_CHECK & opcode=0x61; opcode=0xFD { build SKIP_CHECK; stop(); }

# PREFIX
: is opcode=0x11 [ es_prefix=1; globalset(inst_next, es_prefix); ] {}
